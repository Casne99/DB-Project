= Documentazione tecnica
:doctype: article
:toc: left
:toclevels: 3
:sectnums:


== Premesse

La presente documentazione descrive il progetto realizzato per il corso di *Basi di Dati* nell’anno accademico 2024/2025.

Il contesto riguarda una catena di *negozi* presso i quali è possibile acquistare *prodotti* di tipologia non specificata. Ogni negozio può effettuare vendite ai *clienti* che ne fanno richiesta. +
I clienti hanno la possibilità di effettuare *acquisti*, richiedere una *tessera fedeltà* per accumulare punti utili allo sblocco di sconti, nonché visualizzare le *fatture* relative ai propri acquisti. +
I *manager* possono gestire i negozi, aggiungere prodotti e definire i prezzi per ciascun punto vendita. +
Essi possono inoltre effettuare ordini verso i *fornitori* per ripristinare la disponibilità dei prodotti in esaurimento. +
Sia clienti che manager devono poter modificare la propria password, mentre solo i manager sono autorizzati a registrare nuove utenze per i clienti.

== Attori principali e relazioni

In questa sezione vengono illustrate le scelte progettuali adottate nella modellazione del dominio, facendo riferimento allo *schema ER* prodotto.

[.text-center]
.Schema ER iniziale
image::diagrams/schema_er_v1.png[align=center,pdfwidth=90%]



Lo schema iniziale evidenzia i principali attori coinvolti e le rispettive relazioni. +
Procedendo da sinistra verso destra, si nota l’entità *Utenza*, utilizzata per registrare le credenziali sia dei clienti sia dei manager. Tali credenziali sono associate in modo univoco a un utente, vincolo garantito da un trigger lato database che sarà analizzato successivamente. +

La relazione tra *Negozio* e *Manager* è di tipo _uno-a-molti_: ogni negozio è gestito da un solo manager, mentre un manager può amministrare più negozi. +
Ciascun negozio possiede i propri orari di apertura e può rilasciare una o più *tessere fedeltà* ai clienti. Tali tessere, pur essendo emesse da un determinato negozio, sono valide in tutta la catena. +
Un negozio può inoltre essere destinatario di uno o più *ordini*.

La relazione tra *Negozio* e *Fornitore* è mediata dagli ordini: ogni ordine è infatti inviato da un fornitore a un negozio e riguarda un singolo *Prodotto*.



[NOTE]
====
L'associazione di un ordine a un solo prodotto è motivata da un preciso requisito dell'applicazione: i manager devono poter inoltrare ordini per un determinato prodotto verso il fornitore che lo offre al prezzo più vantaggioso. +
Permettere a un ordine di includere più prodotti avrebbe comportato una complessità maggiore, trasformando il problema da un semplice confronto di prezzi a un’ottimizzazione globale del costo complessivo dell’ordine.
====



I *prodotti* sono inoltre associati alle *fatture* dei clienti. +
È possibile osservare una chiara somiglianza tra le entità *Fornitore* e *Negozio*: entrambe rappresentano punti di deposito di prodotti, dotati di un indirizzo, in grado di vendere articoli a un determinato prezzo e quantità. +
Per tale ragione è stata introdotta l’entità astratta *Punto Deposito*, posta alla radice di una gerarchia di generalizzazione. A tale livello sono stati definiti gli attributi comuni (come l'indirizzo) e le relazioni relative alla disponibilità e ai prezzi dei prodotti.

A partire da questo schema concettuale è stato prodotto uno *schema ristrutturato*, che mantiene tutte le entità della gerarchia e le connette mediante la relazione *IS_A*. +
Sono inoltre stati ristrutturati alcuni attributi composti, come ad esempio l’attributo _Orari_ dell’entità *Negozio*.



[.text-center]
.Schema ER ristrutturato
image::diagrams/schema_er_v2.png[align=center,pdfwidth=90%]




== Implementazione Database

A partire dallo schema ER ristrutturato, la creazione della struttura del database è quasi automatica. +
Possiamo fare dei commenti sulle tabelle sulla base del diagramma generato da *DBeaver*, ambiente da me usato per costruire
la base di dati:

image::diagrams/catena_negozi.png[align=center,pdfwidth=90%]


=== Tabelle principali

* *clienti*
** Identificati tramite codice fiscale
** Contiene informazioni anagrafiche (nome, cognome, genere)
** Collegata a utenze per l'accesso

* *utenze*
** Contiene le credenziali di accesso per clienti e manager (login, password)

* *tessere*
** Rilasciate ai clienti
** Traccia dei punti accumulati e del negozio che l’ha emessa
** Implementate come entità debole, la chiave primaria è anche chiave esterna

* *manager*
** Contiene dati personali e login per autenticazione

* *negozi*
** Riferisce al manager responsabile
** Include orari di apertura/chiusura e stato attivo/inattivo

* *prodotti*
** Elenco dei prodotti disponibili (nome, descrizione)

* *punti_deposito*
** Località in cui vengono stoccati i prodotti
** A questa entità si riferiscono le tabelle che riportano i costi e le disponibilità dei prodotti

* *disponibilità*
** Relazione tra deposito e prodotto con quantità disponibili

* *costi*
** Prezzo del prodotto in ciascun deposito

* *fornitori*
** Identificati da id e partita iva

* *ordini*
** Collegati a un fornitore e a un negozio
** Tracciano data di consegna e stato (completato o no)

* *prodotti_ordine*
** Associazione tra ordini e prodotti, con quantità richieste

* *fatture*
** Collegate a un cliente
** Registrano sconto applicato (se presente), totale e data di acquisto

* *prodotti_fattura*
** Relazione molti-a-molti tra fatture e prodotti, con quantità acquistate

=== Tabelle di supporto

* *storico_ordini*
** Tabella con lo storico di tutti gli ordini effettuati, alimentata da un meccanismo attivo lato database

* *storico_tessere*
** Tabella con lo storico di tutte le tessere emesse, alimentata da un meccanismo attivo lato database

* *tessere_oltre_300*
** Vista contenente tutte le tessere con 300 o più punti


== Trigger e funzioni

Segue la lista delle funzioni SQL realizzate e degli eventuali trigger associati:

[listing]
----
CREATE TRIGGER trigger_aggiorna_punti AFTER INSERT
ON develop.fatture FOR EACH ROW EXECUTE FUNCTION develop.aggiorna_punti();

CREATE OR REPLACE FUNCTION develop.aggiorna_punti()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    UPDATE develop.tessere
    SET punti = punti + FLOOR(NEW.totale)
    WHERE proprietario = NEW.cliente;

    RETURN NULL;
END;
$function$
;
----

Si spiega da se, è associata a un trigger che scatta dopo l'inserimento di una nuova fattura nella tabella fatture e aggiorna il saldo
punti del cliente che ha effettuato l'acquisto.



[listing]
----
CREATE TRIGGER check_login_exclusive_clienti BEFORE
INSERT OR UPDATE
ON develop.clienti FOR EACH ROW EXECUTE FUNCTION develop.check_login_exclusivity();

CREATE TRIGGER check_login_exclusive_manager BEFORE
INSERT OR UPDATE
ON develop.manager FOR EACH ROW EXECUTE FUNCTION develop.check_login_exclusivity();

CREATE OR REPLACE FUNCTION develop.check_login_exclusivity()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Verifica se il login è già presente nell'altra tabella
    IF TG_TABLE_NAME = 'clienti' THEN
        IF EXISTS (SELECT 1 FROM develop.manager WHERE login = NEW.login) THEN
            RAISE EXCEPTION 'Login % già associato a un manager', NEW.login;
        END IF;
    ELSIF TG_TABLE_NAME = 'manager' THEN
        IF EXISTS (SELECT 1 FROM develop.clienti WHERE login = NEW.login) THEN
            RAISE EXCEPTION 'Login % già associato a un cliente', NEW.login;
        END IF;
    END IF;
    RETURN NEW;
END;
$function$
;
----

Trigger che si attiva dopo l'inserimento di tuple nella tabella manager e nella tabella clienti.  +
Controlla che l'utenza non sia già associata ad un profilo esistente.

[listing]
----
CREATE TRIGGER trigger_salva_storico_tessere BEFORE
UPDATE OF attivo
ON develop.negozi FOR EACH ROW EXECUTE FUNCTION develop.salva_storico_tessere();

CREATE OR REPLACE FUNCTION develop.salva_storico_tessere()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF OLD.attivo AND NOT NEW.attivo THEN
        INSERT INTO develop.storico_tessere (proprietario, punti, negozio_di_rilascio, data_richiesta)
        SELECT proprietario, punti, negozio_di_rilascio, data_richiesta
        FROM develop.tessere
        WHERE negozio_di_rilascio = OLD.id;
    END IF;

    RETURN NEW;
END;
$function$
;
----
Salvataggio dello storico tessere associate ad un negozio che viene eliminato logicamente dal database.

[listing]
----
CREATE TRIGGER trg_storico_ordini AFTER
INSERT ON develop.ordini
FOR EACH ROW EXECUTE FUNCTION develop.tr_storico_ordini_insert();

CREATE OR REPLACE FUNCTION develop.tr_storico_ordini_insert()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    INSERT INTO develop.storico_ordini (ordine_id, data_consegna, negozio_id, fornitore_id)
    VALUES (NEW.id, NEW.data_consegna, NEW.negozio, NEW.fornitore);

    RETURN NEW;
END;
$function$
;
----


[listing]
----
CREATE TRIGGER trg_completamento_ordine AFTER
UPDATE
    OF completato ON
    develop.ordini FOR EACH ROW EXECUTE FUNCTION develop.aggiorna_disponibilita_al_completamento();

CREATE OR REPLACE FUNCTION develop.aggiorna_disponibilita_al_completamento()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    r RECORD;
BEGIN
    IF NEW.completato AND NOT OLD.completato THEN
        FOR r IN
            SELECT prodotto, quantita
            FROM develop.prodotti_ordine
            WHERE ordine = NEW.id
        LOOP
            INSERT INTO develop.disponibilita (deposito, prodotto, quantita)
            VALUES (NEW.negozio, r.prodotto, r.quantita)
            ON CONFLICT (prodotto, deposito) DO UPDATE
            SET quantita = develop.disponibilita.quantita + EXCLUDED.quantita;
        END LOOP;
    END IF;

    RETURN NEW;
END;
$function$
;
----
Funzione attiva che aggiorna la disponibilità del materiale presso un negozio al completamento di un ordine.
Il completamento dell'ordine avviene quando viene settato il relativo flag.


[listing]
----
CREATE OR REPLACE FUNCTION develop.get_ordini_fornitore(fornitore character varying)
 RETURNS SETOF integer
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY SELECT o.id
	FROM ordini AS o
	WHERE o.fornitore = fornitore;
END;
$function$
;
----
Funzione attiva che recupera tutti gli ordini associati ad un fornitore.


[listing]
----
CREATE OR REPLACE FUNCTION develop.get_tessere_negozio(negozio character varying)
 RETURNS TABLE(proprietario character)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY SELECT t.proprietario
	FROM tessere AS t
	WHERE t.negozio_di_rilascio = $1;
END;
$function$
;
----
Funzione attiva che recupera tutti le tessere emesse da un dato negozio.


[listing]
----
CREATE OR REPLACE FUNCTION develop.inserisci_ordine_ottimizzato(negozio_id text, prodotti_json json)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    record JSON;
    prodotto_id TEXT;
    quantita_richiesta INTEGER;
    fornitore_id TEXT;
    ordine_id INTEGER;
BEGIN
    FOR record IN SELECT * FROM json_array_elements(prodotti_json) LOOP
        prodotto_id := record->>'prodotto';
        quantita_richiesta := (record->>'quantita')::INTEGER;

        -- Trova il fornitore più economico con disponibilità sufficiente per questo prodotto
        SELECT f.id INTO fornitore_id
        FROM develop.fornitori f
        JOIN develop.disponibilita d ON d.deposito = f.id AND d.prodotto = prodotto_id
        JOIN develop.costi pr ON pr.deposito = f.id AND pr.prodotto = prodotto_id
        WHERE d.quantita >= quantita_richiesta
        ORDER BY pr.prezzo ASC
        LIMIT 1;

        IF fornitore_id IS NULL THEN
            RAISE EXCEPTION 'Nessun fornitore ha disponibilità sufficiente per il prodotto %', prodotto_id;
        END IF;

        -- Inserisci l'ordine per questo singolo prodotto presso il miglior fornitore
        INSERT INTO develop.ordini (data_consegna, negozio, fornitore)
        VALUES (CURRENT_DATE, negozio_id, fornitore_id)
        RETURNING id INTO ordine_id;

        INSERT INTO develop.prodotti_ordine (ordine, prodotto, quantita)
        VALUES (ordine_id, prodotto_id, quantita_richiesta);

        UPDATE develop.disponibilita
        SET quantita = quantita - quantita_richiesta
        WHERE prodotto = prodotto_id AND deposito = fornitore_id;
    END LOOP;
END;
$function$
;
----
Funzionalità richiamata dalla GUI che inserisce potenzialmente più ordini contemporaneamente presso il miglior fornitore per un dato prodotto.
La struttura del JSON in input è del tipo prodotto: <id prodotto>, quantita: <quantita da ordinare>.

[listing]
----
CREATE OR REPLACE FUNCTION develop.inserisci_fattura_con_sconto_json(p_cliente character, p_deposito character varying, p_prodotti_json jsonb, p_sconto_percentuale numeric DEFAULT 0)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_punti_cliente INT := 0;
    v_punti_da_scalare INT := 0;
    v_sconto_applicato NUMERIC(5,2) := 0;
    v_id_fattura INT;
    prod_rec jsonb;
    v_prodotto varchar(7);
    v_quantita int;
    v_prezzo_unitario numeric(8,2);
    v_totale numeric := 0;
    v_soglia_punti INT;
    v_percentuale_sconto NUMERIC;
BEGIN
    -- Controllo punti solo se lo sconto è diverso da zero
    IF p_sconto_percentuale <> 0 THEN
        SELECT punti INTO v_punti_cliente
        FROM develop.tessere
        WHERE proprietario = p_cliente;

        IF v_punti_cliente IS NULL THEN
            RAISE EXCEPTION 'Tessera non trovata per il cliente %, impossibile applicare sconto', p_cliente;
        END IF;
    END IF;

    -- Calcolo totale basato sui prezzi nel deposito
    FOR prod_rec IN SELECT * FROM jsonb_array_elements(p_prodotti_json)
    LOOP
        v_prodotto := prod_rec ->> 'prodotto';
        v_quantita := (prod_rec ->> 'quantita')::int;

        SELECT c.prezzo INTO v_prezzo_unitario
        FROM develop.costi c
        JOIN develop.negozi n ON c.deposito = n.id
        WHERE c.deposito = p_deposito AND c.prodotto = v_prodotto AND n.attivo;

        IF v_prezzo_unitario IS NULL THEN
            RAISE EXCEPTION 'Prezzo non trovato per prodotto % nel deposito %', v_prodotto, p_deposito;
        END IF;

        v_totale := v_totale + (v_prezzo_unitario * v_quantita);
    END LOOP;

    -- Calcolo sconto
    IF p_sconto_percentuale = 0 THEN
        v_punti_da_scalare := 0;
        v_sconto_applicato := 0;
    ELSE
        SELECT
            CASE p_sconto_percentuale
                WHEN 5 THEN 100
                WHEN 15 THEN 200
                WHEN 30 THEN 300
                ELSE NULL
            END,
            p_sconto_percentuale
        INTO v_soglia_punti, v_percentuale_sconto;

        IF v_soglia_punti IS NULL THEN
            RAISE EXCEPTION 'Percentuale sconto non valida';
        END IF;

        IF v_punti_cliente < v_soglia_punti THEN
            RAISE EXCEPTION 'Punti insufficienti per applicare sconto %%%', v_percentuale_sconto;
        END IF;

        v_punti_da_scalare := v_soglia_punti;
        v_sconto_applicato := LEAST(v_totale * (v_percentuale_sconto / 100), 100);
    END IF;

    -- Inserimento fattura con negozio
    INSERT INTO develop.fatture (
        sconto_applicato,
        totale,
        data_acquisto,
        cliente,
        negozio
    )
    VALUES (
        v_sconto_applicato,
        v_totale - v_sconto_applicato,
        CURRENT_DATE,
        p_cliente,
        p_deposito
    )
    RETURNING id INTO v_id_fattura;

    -- Aggiorna prodotti_fattura e disponibilità per ogni prodotto
    FOR prod_rec IN SELECT * FROM jsonb_array_elements(p_prodotti_json)
    LOOP
        v_prodotto := prod_rec ->> 'prodotto';
        v_quantita := (prod_rec ->> 'quantita')::int;

        INSERT INTO develop.prodotti_fattura (prodotto, fattura, quantita)
        VALUES (v_prodotto, v_id_fattura, v_quantita);

        UPDATE develop.disponibilita
        SET quantita = quantita - v_quantita
        WHERE deposito = p_deposito
          AND prodotto = v_prodotto
          AND quantita >= v_quantita;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Disponibilità insufficiente per il prodotto % nel deposito %', v_prodotto, p_deposito;
        END IF;
    END LOOP;

    -- Aggiorna i punti tessera solo se lo sconto è stato applicato
    IF v_punti_da_scalare > 0 THEN
        UPDATE develop.tessere
        SET punti = punti - v_punti_da_scalare
        WHERE proprietario = p_cliente;
    END IF;

    RETURN v_id_fattura;
END;
$function$
;
----
Funzionalità richiamata dalla GUI che inserisce una fattura nella tabella fatture e aggiorna la tabella prodotti_fattura, contenente le informazioni
sui prodotti interessati dai singoli acquisti.

== Prove di funzionamento



